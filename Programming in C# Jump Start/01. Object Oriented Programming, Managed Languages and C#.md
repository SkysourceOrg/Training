# Object Oriented Programming, Managed Languages and C#



## Objected Oriented Programming

### Encapsulation
Encapsulation means that a group of related properties, methods, and other members are treated as a single unit or object. It can create a boundary around an object to separate its external (public) behavior from its internal (private) implementation. Consumers of an object should only concern themselves with *what an object does*, not *how it does it*.  

C# supports Encapsulation via:  

* Unified Type System
* Class and Interfaces
* Properties, Methods and Events

### Inheritance
[Inheritance] describes the ability to create new classes based on an existing class.  

C# implements [Inheritance] in two ways:  

* A class may inherit from a single base class
* A class may implement zero or more interfaces

### Polymorphism
[Polymorphism] means that you can have multiple classes that can be used interchangeably, even though each class implements the same properties or methods in different ways.  

Two aspects of [Polymorphism]:  

* At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays. When this occurs, the object's declared type is no longer identical to its run-time type.
* Base classes may define and implement virtual methods, and derived classes can override them, which means they provide their own definition and implementation. At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method. Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.

## Managed Language
Managed languages depend on services provided by a runtime environment. C# is one of many languages that compile into managed code. Managed code is executed by the [Common Language Runtime](CLR).  

### Features of CLR
* Automatic memory management
* Exception handling
* Standard type
* Security


## Type

### Value Type
Variables that are based on [Value Type] directly contains values. Assigning one [Value Type] variable to another copies the contained value.  

The value types consist of two main categories:  

* Structs
  * Numeric types
  * bool
  * User defined structs
* Enumerations
    
    
Here are the main features of [Value Type]:

* Canâ€™t derive a new type from a value type.
* Structs can implement interfaces
* Value type cannot contain the null value.
* The nullable types (ex. int?) feature does allow for value types to be assigned to null.      
* Default constructor to initialize default value

### Reference Type
The assignment of [Reference Type] variables copies a reference to the object (actual data) but not the object itself.  

The following keywords are used to declare [Reference Type]:

* class
* interface
* delegate

C# also provides the following built-in [Reference Type]:  

* dynamic
* object
* string

### Pointer Type

## Lambda Expression
A [Lambda Expression] is an anonymous function that you can use to create delegates or expression tree types. By using [Lambda Expression], you can write local functions that can be passed as arguments or returned as the value of function calls. 

* [Lambda Expression] is validated at compile time, but evaluated at run time.
* [Lambda Expression] is used in method-based LINQ queries as arguments to standard query operator methods such as Where.

## Anonymous Type
[Anonymous Type] (var) provides a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.  

* The type name is generated by the compiler and is not available at the source code level. 
* The type of each property is inferred by the compiler.
* [Anonymous Type] typically is used in the select clause of a query expression to return a subset of the properties from each object in the source sequence. 

## Extension Method
[Extension Method] enables you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.

* [Extension Method] is defined as static method but is called by using instance method syntax.
* Their first parameter specifies which type the method operates on, and the parameter is preceded by the this modifier. 
* [Extension Method] is only in scope when you explicitly import the namespace into your source code with a using directive.



[Anonymous Type]:http://goo.gl/fYwrb
[Common Language Runtime]:http://goo.gl/y9xMBj
[Extension Method]:http://goo.gl/ww2sMj
[Inheritance]:http://goo.gl/lHbsHq
[Lambda Expression]:http://goo.gl/MU84j
[Polymorphism]:http://goo.gl/4aaA5
[Reference Type]:http://goo.gl/5r0xh
[Value Type]:http://goo.gl/cXlUW
